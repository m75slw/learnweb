if(typeof AWPageMounts=='undefined'){AWPageMounts={}};AWPageMounts['m007']=[{"name":"01-ES6.md","path":"007-ES6新特性/01-ES6.md","content":"#### ES6新特性\r\n\r\n##### let命令：\r\n\r\n###### 不存在变量的提升：\r\n\r\nvar命令可以在变量声明之前使用，值为undefined。\r\n\r\nlet必须在之后使用。\r\n\r\n###### 暂时性死区：\r\n\r\n只要块级作用域内，存在**let**命令，它所声明的变量就绑定(binding)这个区域，不再受外部影响。\r\n\r\n暂时性死区：在代码块内，使用let命令声明之前，该变量都是不可用的。\r\n\r\ntype of x；\tx=y y=2；\tx=x；\r\n\r\n###### 不允许重复声明：\r\n\r\n同一作用域，不能用let声明两个相同的变量。\r\n\r\n不能再函数内部重新声明参数。可以包个{}。\r\n\r\n##### 块级作用域：\r\n\r\n###### 需要块级作用域的原因：\r\n\r\n1.内层变量可能会覆盖外层变量。\r\n\r\n2.用来计数的循环变量泄露为全局变量。\r\n\r\n​\tfor循环中i只用来控制循环，但是循环结束后并没有消失，泄露成了全局变量。\r\n\r\n###### ES6的块级作用域：\r\n\r\nES6允许块作用域的任意嵌套。\r\n\r\n内层作用域可以定义外层作用域的同名变量。\r\n\r\n块级作用域的出现，使得获得广泛应用的匿名立即执行函数表达式（IFEE自调用）不再必要了。\r\n\r\n###### 块级作用域与函数声明：\r\n\r\nES5规定，函数只能在顶层作用域和函数作用域中声明，不能在块级作用域声明。\r\n\r\nES6引入了块级作用域，明确允许在块级作用域中声明函数。行为类似let，在块级作用域之外不可引用。\r\n\r\n为了减轻不兼容问题，ES6规定：\r\n\r\n​\t1.允许函数在块级作用域内声明函数。\r\n\r\n​\t2.函数声明类似于var，即会提升到全局作用域或函数作用域的头部\r\n\r\n​\t3.同时，函数声明还会提升到所在块级作用域的头部。\r\n\r\n以上三条规则，只对ES6浏览器有效，其他环境不用遵守，还是将块级作用域的函数声明当作let处理。\r\n\r\n所以考虑到，环境导致的行为差异太大，应该避免在块级作用域内声明函数，如果确实需要，也应该写成函数表达式。\r\n\r\nES6的块级作用域必须有大括号，如果没有大括号，js引擎就会认为不存在块级作用域。\r\n\r\n##### const命令：\r\n\r\nconst是一个只读常量，一旦声明，常量的值就不可改变。所以一旦声明就必须立即初始化。\r\n\r\n`const`的作用域与`let`命令相同：只在声明所在的块级作用域内有效。\r\n\r\n`const`命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。\r\n\r\n`const`声明的常量，也与`let`一样不可重复声明。\r\n\r\n###### 本质：\r\n\r\nconst实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。\r\n\r\n对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的。\r\n\r\n###### object.freeze():\r\n\r\n###### 六种变量声明方式：\r\n\r\nvar\t\tfunction\r\n\r\nlet\t\tconst\r\n\r\nimport\t\tclass\r\n\r\n##### 顶层对象的属性：\r\n\r\nES6 ，一方面规定，为了保持兼容性，`var`命令和`function`命令声明的全局变量，依旧是顶层对象的属性；\r\n\r\n另一方面规定，`let`命令、`const`命令、`class`命令声明的全局变量，不属于顶层对象的属性。\r\n\r\n也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。\r\n\r\n##### globalThis对象：\r\n","timestamp":1635919853077}]