#### ES6新特性

##### let命令：

###### 不存在变量的提升：

var命令可以在变量声明之前使用，值为undefined。

let必须在之后使用。

###### 暂时性死区：

只要块级作用域内，存在**let**命令，它所声明的变量就绑定(binding)这个区域，不再受外部影响。

暂时性死区：在代码块内，使用let命令声明之前，该变量都是不可用的。

type of x；	x=y y=2；	x=x；

###### 不允许重复声明：

同一作用域，不能用let声明两个相同的变量。

不能再函数内部重新声明参数。可以包个{}。

##### 块级作用域：

###### 需要块级作用域的原因：

1.内层变量可能会覆盖外层变量。

2.用来计数的循环变量泄露为全局变量。

​	for循环中i只用来控制循环，但是循环结束后并没有消失，泄露成了全局变量。

###### ES6的块级作用域：

ES6允许块作用域的任意嵌套。

内层作用域可以定义外层作用域的同名变量。

块级作用域的出现，使得获得广泛应用的匿名立即执行函数表达式（IFEE自调用）不再必要了。

###### 块级作用域与函数声明：

ES5规定，函数只能在顶层作用域和函数作用域中声明，不能在块级作用域声明。

ES6引入了块级作用域，明确允许在块级作用域中声明函数。行为类似let，在块级作用域之外不可引用。

为了减轻不兼容问题，ES6规定：

​	1.允许函数在块级作用域内声明函数。

​	2.函数声明类似于var，即会提升到全局作用域或函数作用域的头部

​	3.同时，函数声明还会提升到所在块级作用域的头部。

以上三条规则，只对ES6浏览器有效，其他环境不用遵守，还是将块级作用域的函数声明当作let处理。

所以考虑到，环境导致的行为差异太大，应该避免在块级作用域内声明函数，如果确实需要，也应该写成函数表达式。

ES6的块级作用域必须有大括号，如果没有大括号，js引擎就会认为不存在块级作用域。

##### const命令：

const是一个只读常量，一旦声明，常量的值就不可改变。所以一旦声明就必须立即初始化。

`const`的作用域与`let`命令相同：只在声明所在的块级作用域内有效。

`const`命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。

`const`声明的常量，也与`let`一样不可重复声明。

###### 本质：

const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。

对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的。

###### object.freeze():

###### 六种变量声明方式：

var		function

let		const

import		class

##### 顶层对象的属性：

ES6 ，一方面规定，为了保持兼容性，`var`命令和`function`命令声明的全局变量，依旧是顶层对象的属性；

另一方面规定，`let`命令、`const`命令、`class`命令声明的全局变量，不属于顶层对象的属性。

也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。

##### globalThis对象：
